/*
by Risa Sundu & David Shin
 References:
 - sparkfun tutorial for serial communication between Processing and Arduino: https://learn.sparkfun.com/tutorials/connecting-arduino-to-processing/all#from-processing
 - cotterjk on stack overflow for pixel magnification: https://stackoverflow.com/questions/73562932/how-to-magnify-display-working-with-pixels-in-processing-java
 - creativecoding on p5.js for grid drawing: https://editor.p5js.org/creativecoding/sketches/duUe1NqJz
 - Nick Gammon on Gammon Forum for buffering serial input: https://www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=11425&page=1
 Thanks also to Molly, Leo, Adin, & Colin @ UCSD's EnVision Maker Studio for lots of support & guidance
 */

import processing.serial.*;
import gab.opencv.*;
import processing.video.*;
import java.awt.Rectangle;
import org.opencv.core.Core;

Serial myPort;  // Create object from Serial class
Capture video;
OpenCV opencv;

PImage img = createImage(27, 24, RGB); // LED is 27 pixels wide x 24 pixels tall

int scaleFactor = 10;
boolean isSpacebarPressed = false; // Track the state of the spacebar

void setup()
{
  size(480 + 270, 480); // Adjusted to display video and LED matrix side by side
  video = new Capture(this, 480, 480);
  opencv = new OpenCV(this, 480, 480);
  opencv.loadCascade(OpenCV.CASCADE_FRONTALFACE);
  video.start();

  frameRate(10);
  clearMatrix();
  noSmooth(); //for crisp resizing

  background(255);

  // initialize serial communication
  String portName = Serial.list()[1]; //change the 0 to a 1 or 2 etc. to match your port
  myPort = new Serial(this, portName, 922190);
}

void draw() {
  if (video.available()) {
    video.read();
    // Flip the video feed horizontally
    pushMatrix(); // Save the current transformation matrix
    translate(video.width, 0); // Move the origin to the right edge of the video
    scale(-1.0, 1.0); // Flip the video feed horizontally
    image(video, 0, 0); // Display the mirrored video feed
    popMatrix(); // Restore the transformation matrix
  }
  opencv.loadImage(video);
  
  // Processing the video and updating the LED matrix follow here as before
  // Note: When drawing detected faces or other features back onto the video,
  // you'll need to adjust their positions according to the mirrored coordinates.

  if (isSpacebarPressed) {
    Rectangle[] faces = opencv.detect(); // Detect faces
    clearLEDMatrix();
    if (faces.length > 0) {
      for (Rectangle face : faces) {
        // Adjust face.x for the mirrored video
        int mirroredX = video.width - (face.x + face.width);
        drawFaceArea(mirroredX, face.y, face.width, face.height);
      }
    }
  } else {
    activateRandomButtons();
  }
  
  image(img, 640, 0, img.width * scaleFactor, img.height * scaleFactor); // Draw the scaled-up LED matrix on the right side of the window
  drawGrid();
}
void keyPressed() {
  if (key == ' ') { // Check if the pressed key is the spacebar
    isSpacebarPressed = true;
  }
}

void keyReleased() {
  if (key == ' ') { // Check if the released key is the spacebar
    isSpacebarPressed = false;
  }
}

void activateRandomButtons() {
  clearMatrix(); // Clear the matrix to start fresh
  int numPixelsToActivate = (img.width * img.height) / 10; // Activate 10% of the grid
  for (int i = 0; i < numPixelsToActivate; i++) {
    int randomX = int(random(img.width));
    int randomY = int(random(img.height));
    img.pixels[randomX + randomY * img.width] = color(100); // Randomly activated pixels colored red
  }
  img.updatePixels();
}
void writeSerial() {
  while (myPort.available() > 0) {
    print((char) myPort.read());
  }


  char red = (char)0;
  //print(red);

  for (int i = img.width-1; i >= 0; i--) {
    for (int j = img.height-1; j >= 0; j--) {

      //initial testing of sending different color data
      if (img.pixels[i*img.height +j] == color(100)) {
        red = (char) 100;//(( img.pixels[i + j*img.width] >> 16 & 0xFF) >> 1);
        //print("x");
      } else if (img.pixels[i*img.height +j] == color(150)) {
        red = (char) 150;
      } else {
        red = (char) 0;
        //print("o");
      }
      myPort.write(red);
    }
  }
  char startChar = 0b11111111; // send end of matrix
  myPort.write(startChar);
  println("writing end bit");
}

void updatePixels() {
  img.loadPixels();

  img.updatePixels();
  image(img, 0, 0, img.width*scaleFactor, img.height*scaleFactor);
}

void drawGrid() {
  //draw 27x24 grid for LED reference
  for (int i = 0; i <= img.width*scaleFactor; i+=scaleFactor) {
    stroke(.25);
    line(i, 0, i, img.height*scaleFactor);
  }
  for (int j = 0; j <= img.height*scaleFactor; j+=scaleFactor) {
    line(0, j, img.width*scaleFactor, j);
  }
}

void clearMatrix() {
  //setup canvas: white = off
  img.loadPixels();
  for (int i = 0; i < img.width; i++) {
    for (int j = 0; j < img.height; j++) {
      img.pixels[i + j*img.width] = color(255);
    }
  }
}

void detectFace() {
  Rectangle[] faces = opencv.detect(); // Detect faces
  
  //trying to mirror camera
  //pushMatrix();
  //  scale(-1,1);

  for (Rectangle face : faces) {
    // Map face dimensions from video resolution to LED matrix resolution
    int ledX = int(map(face.x, 0, video.width, 0, img.width));
    int ledY = int(map(face.y, 0, video.height, 0, img.height));
    int ledW = int(map(face.width, 0, video.width, 0, img.width));
    int ledH = int(map(face.height, 0, video.height, 0, img.height));

    // Highlight the area within the face detection
    highlightFace(ledX, ledY, ledW, ledH);

  }
      //popMatrix();
}

void highlightFace(int x, int y, int w, int h) {
  for (int i = x; i < x + w; i++) {
    for (int j = y; j < y + h; j++) {
      if (i >= 0 && i < img.width && j >= 0 && j < img.height) {
        img.pixels[i + j * img.width] = color(100); // Set color for simulated 'click'
      }
    }
  }
  // make face a little less rectangular
  img.pixels[x+y*img.width] = color(255);
  img.pixels[(x+w-1)+y*img.width] = color(255);
  img.pixels[x+(y+h-1)*img.width] = color(255);
  img.pixels[(x+w-1)+(y+h-1)*img.width] = color(255);

  img.updatePixels();
}
